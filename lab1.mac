!Вход в постпроцессор
/POST1

!Считывание числа шагов метода последовательных нагружений (в переменную num_iter)
SET,LAST
*GET,num_iter,ACTIVE, ,SET,SBST   

!Создаем пустые массивы для силы, перемещения, жесткости   
*DIM,F_gr, ARRAY, num_iter
*DIM,V_gr, ARRAY, num_iter
*DIM,K_gr, ARRAY, num_iter

!Вычисляем номер узла, в котором приложена сила (координаты узла L1+L2+L3;-H1)
NSEL,S,LOC,X,L1+L2+L3  
NSEL,R,LOC,Y,-H1  
*GET,Nnum,NODE,,NUM,MAX, , ,
ALLSEL,ALL

!Организуем цикл в котором будем последовательно считывать решение на каждом шаге метода последовательных нагружений
*do,j,1,num_iter,1

!Считываем результаты расчета на j шаге
SET,,, ,,, ,j   

!Счтываем величину квазивремени на текущем шаге

*GET,tt,ACTIVE, ,SET,TIME

!Вычисляем силу на текущем шаге и записываем ее в массив F_gr
F_gr(j)=tt*F

!Считываем вертикальное перемещение узла, в котором приложена нагрузка
*GET,W,NODE,Nnum,U,Y

!записываем абсолютное значение перемещения в массив V_gr
V_gr(j)=abs(W)

*ENDDO

!Вычисляем величину жесткости на каждом шаге нагружения и записываем ее в массив K_gr

K_gr(2)=(F_gr(2)-F_gr(1))/(V_gr(2)-V_gr(1))
K_gr(1)=K_gr(2)

*do,j,3,num_iter-1,1
K_gr(j)=(F_gr(j+1)-F_gr(j-1))/(V_gr(j+1)-V_gr(j-1))
*enddo

K_gr(num_iter)=(F_gr(num_iter)-F_gr(num_iter-1))/(V_gr(num_iter)-V_gr(num_iter-1))


!Сохраняем полученные массивы в виде текстового файла
*CREATE,'macros1',' ',' '   
*cfopen,data_file,txt   
*VWRITE,F_gr(1),V_gr(1), K_gr(1)
('F=',F10.4,' V=',F10.4,' K=',F10.4)
*CFCLOS 
*END
*use,macros1

!Вызываем диалоговое окно, предлагающее какой график вывести на экран
*ask,key,Print graphic: 1-V(F) ; 2-K(F); (Default 1),1

!Вывод на экран графика K(F) (если введенное число равно 2)
*IF,key,EQ,2,THEN
*VPLOT,F_gr,K_gr, , , , , , , , 
*ENDIF

!Вывод на экран графика V(F) (если введенное число не равно 2)
*IF,key,NE,2,THEN
*VPLOT,F_gr,V_gr, , , , , , , , 
*ENDIF
